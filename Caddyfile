# Caddy v2 with Cloudflare DNS module

irisvision.ai, www.irisvision.ai {
	# Disable compression and buffering for SSE streaming endpoints (prevents buffering delays)
	@sse path /api/chat/*/stream /api/agent-run/*/stream /api/simple/*/stream
	reverse_proxy @sse backend:8000 {
		# Critical: Flush immediately for streaming responses (disable buffering)
		# -1 means flush on every write, enabling real-time streaming
		flush_interval -1
	}
	# Remove compression headers and set streaming headers for SSE endpoints
	header @sse -Content-Encoding
	header @sse -Accept-Encoding
	header @sse X-Accel-Buffering "no"
	header @sse Cache-Control "no-cache"
	
	# Enable compression for other endpoints
	@not_sse not path /api/chat/*/stream /api/agent-run/*/stream /api/simple/*/stream
	encode @not_sse zstd gzip

	# Health check (HTTPS)
	@health path /health
	respond @health "OK" 200

	# Redirect www → apex
	@www host www.irisvision.ai
	redir @www https://irisvision.ai{uri} permanent

	# API + WebSockets → backend
	@api path /api/* /ws/*
	reverse_proxy @api backend:8000 {
		# For non-streaming endpoints, use default buffering
		# But ensure streaming endpoints are handled by @sse matcher above
	}

	# Everything else → frontend (Next.js)
	reverse_proxy frontend:3000

	# Security headers
	header {
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
		X-Content-Type-Options "nosniff"
		X-Frame-Options "DENY"
		Referrer-Policy "strict-origin-when-cross-origin"
		X-XSS-Protection "1; mode=block"
	}

	# Access logs to stdout (recommended in containers)
	log {
		output stdout
		format json
	}
}

vault.irisvision.ai, *.vault.irisvision.ai {
	encode zstd gzip

	tls {
		dns cloudflare {env.CLOUDFLARE_API_TOKEN}
	}

	@health path /health
	respond @health "OK" 200

	reverse_proxy sandbox-proxy:1234

	log {
		output stdout
		format json
	}
}

# Optional: Plain HTTP listener for health + redirect to HTTPS
:80 {
	@health path /health
	respond @health "OK" 200
	redir https://irisvision.ai{uri}
}
